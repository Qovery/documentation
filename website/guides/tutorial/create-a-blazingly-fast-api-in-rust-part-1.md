---
last_modified_on: "2024-05-03"
$schema: "/.meta/.schemas/guides.json"
title: Create a blazingly fast REST API in Rust (Part 1/2)
description: How to create a blazingly fast REST API in Rust, with zero-cost abstraction and very low overhead - Part 1/2
author_github: https://github.com/evoxmusic
tags: ["type: tutorial", "language: rust"]
hide_pagination: true
---

import Steps from '@site/src/components/Steps';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

import Alert from '@site/src/components/Alert';
import Assumptions from '@site/src/components/Assumptions';
import Jump from '@site/src/components/Jump';

> [Fast, reliable, productive - Pick three](https://github.com/rust-lang/www.rust-lang.org/issues/419#issuecomment-443418587) | Rust's slogan

Rust is a systems programming language that runs blazingly fast, prevents segfaults, and guarantees thread safety. Coupled with Actix, I should be able to build a fast REST API elegantly.

The idea behind this article is to see how performant a Rust API can be. I am going to create an API that saves and reads data from/to a PostgreSQL database.

<Alert type="info">

Most of the Rust REST API tests across the web are "[Hello World](https://medium.com/sean3z/rest-api-node-vs-rust-c75aa8c96343)" applications. They bench direct API I/O with no payload. It's very far from reality. In the part 2 of this article, I will bench our Rust application with an intensive payload.

</Alert>

This article is separate in two parts, in this first part you will learn how to:

* Create a blazingly fast REST API in Rust
* Connect it to a PostgreSQL database

In the second part, we will compare the performance of our application to a Go application.

<!--
     THIS FILE IS AUTOGENERATED!

     To make changes please edit the template located at:

     website/guides/tutorial/create-a-blazingly-fast-api-in-rust-part-1.md.erb
-->

## Twitter clone

> [Twitter](https://www.twitter.com) is a "microblogging" system that allows people to send and receive short posts called tweets.

Let's create a small part of the Twitter API to be able to post, read, and like tweets. The goal is to be able to use our Twitter clone with a massive number of simultaneous fake users.

<Assumptions>

* You have installed [Cargo](https://github.com/rust-lang/cargo) (Rust package manager)

</Assumptions>

### API design

Our REST API needs to have three endpoints :

* **/tweets**
  * GET: list last 50 tweets
  * POST: create a new tweet
* **/tweets/:id**
  * GET: find a tweet by its ID
  * DELETE: delete a tweet by its ID
* **/tweets/:id/likes**
  * GET: list all likes attached to a tweet
  * POST: add +1 like to a tweet
  * DELETE: add -1 like to a tweet

<Alert type="info">

For the sake of simplicity, I will not set up a user management service.

</Alert>

## Implementation

Even though implementing an HTTP server could be fun, I choose to use [Actix](https://actix.rs/), which is ranked as [the most performant framework](https://www.techempower.com/benchmarks/#section=data-r18&hw=ph&test=fortune) ever by *Techempower*.

### Actix Web

Actix is an actor framework prevalent in the Rust ecosystem. I am using it as an HTTP server to build our REST API.

### Let's code

Three files structured our application.
* `main.rs` to route HTTP requests to the right endpoint
* `tweet.rs` to handle requests on /tweets
* `like.rs` to handle requests on /tweets/:id/likes

<Tabs
  centered={false}
  className={"square"}
  defaultValue={"main.rs"}
  select={false}
  size={null}
  values={[{"group":"Files","label":"main.rs","value":"main.rs"},{"group":"Files","label":"tweet.rs","value":"tweet.rs"},{"group":"Files","label":"like.rs","value":"like.rs"}]}>

<TabItem value="main.rs">

```rust title="main.rs"
#[actix_rt::main]
async fn main() -> io::Result<()> {
    env::set_var("RUST_LOG", "actix_web=debug,actix_server=info");
    env_logger::init();

    HttpServer::new(|| {
        App::new()
            // enable logger - always register actix-web Logger middleware last
            .wrap(middleware::Logger::default())
            // register HTTP requests handlers
            .service(tweet::list)
            .service(tweet::get)
            .service(tweet::create)
            .service(tweet::delete)
            .service(like::list)
            .service(like::plus_one)
            .service(like::minus_one)
    })
    .bind("0.0.0.0:9090")?
    .run()
    .await
}
```

[main.rs source code](https://github.com/evoxmusic/twitter-clone-rust/blob/487198ee7b306f36dbab01f40a44345f85387db2/src/main.rs)

</TabItem>

<TabItem value="tweet.rs">

```rust title="tweet.rs"
pub type Tweets = Response<Tweet>;

#[derive(Debug, Deserialize, Serialize)]
pub struct Tweet {
    pub id: String,
    pub created_at: DateTime<Utc>,
    pub message: String,
    pub likes: Vec<Like>,
}

impl Tweet {
    pub fn new(message: String) -> Self {
        Self {
            id: Uuid::new_v4().to_string(),
            created_at: Utc::now(),
            message,
            likes: vec![],
        }
    }
}

#[derive(Debug, Deserialize, Serialize)]
pub struct TweetRequest {
    pub message: Option<String>,
}

impl TweetRequest {
    pub fn to_tweet(&self) -> Option<Tweet> {
        match &self.message {
            Some(message) => Some(Tweet::new(message.to_string())),
            None => None,
        }
    }
}

/// list 50 last tweets `/tweets`
#[get("/tweets")]
pub async fn list() -> HttpResponse {
    // TODO find the last 50 tweets and return them

    let tweets = Tweets { results: vec![] };

    HttpResponse::Ok()
        .content_type(APPLICATION_JSON)
        .json(tweets)
}

/// create a tweet `/tweets`
#[post("/tweets")]
pub async fn create(tweet_req: Json<TweetRequest>) -> HttpResponse {
    HttpResponse::Created()
        .content_type(APPLICATION_JSON)
        .json(tweet_req.to_tweet())
}

/// find a tweet by its id `/tweets/{id}`
#[get("/tweets/{id}")]
pub async fn get(path: Path<(String,)>) -> HttpResponse {
    // TODO find tweet a tweet by ID and return it
    let found_tweet: Option<Tweet> = None;

    match found_tweet {
        Some(tweet) => HttpResponse::Ok()
            .content_type(APPLICATION_JSON)
            .json(tweet),
        None => HttpResponse::NoContent()
            .content_type(APPLICATION_JSON)
            .await
            .unwrap(),
    }
}

/// delete a tweet by its id `/tweets/{id}`
#[delete("/tweets/{id}")]
pub async fn delete(path: Path<(String,)>) -> HttpResponse {
    // TODO delete tweet by ID
    // in any case return status 204

    HttpResponse::NoContent()
        .content_type(APPLICATION_JSON)
        .await
        .unwrap()
}
```

[tweet.rs source code](https://github.com/evoxmusic/twitter-clone-rust/blob/487198ee7b306f36dbab01f40a44345f85387db2/src/tweet.rs)

</TabItem>

<TabItem value="like.rs">

```rust title="like.rs"
pub type Likes = Response<Like>;

#[derive(Debug, Deserialize, Serialize)]
pub struct Like {
    pub id: String,
    pub created_at: DateTime<Utc>,
}

impl Like {
    pub fn new() -> Self {
        Self {
            id: Uuid::new_v4().to_string(),
            created_at: Utc::now(),
        }
    }
}

/// list last 50 likes from a tweet `/tweets/{id}/likes`
#[get("/tweets/{id}/likes")]
pub async fn list(path: Path<(String,)>) -> HttpResponse {
    // TODO find likes by tweet ID and return them
    let likes = Likes { results: vec![] };

    HttpResponse::Ok()
        .content_type(APPLICATION_JSON)
        .json(likes)
}

/// add one like to a tweet `/tweets/{id}/likes`
#[post("/tweets/{id}/likes")]
pub async fn plus_one(path: Path<(String,)>) -> HttpResponse {
    // TODO add one like to a tweet
    let like = Like::new();

    HttpResponse::Created()
        .content_type(APPLICATION_JSON)
        .json(like)
}

/// remove one like from a tweet `/tweets/{id}/likes`
#[delete("/tweets/{id}/likes")]
pub async fn minus_one(path: Path<(String,)>) -> HttpResponse {
    // TODO remove one like to a tweet
    HttpResponse::NoContent()
        .content_type(APPLICATION_JSON)
        .await
        .unwrap()
}
```

[like.rs source code](https://github.com/evoxmusic/twitter-clone-rust/blob/487198ee7b306f36dbab01f40a44345f85387db2/src/like.rs)

</TabItem>

</Tabs>

With only these three files, our application is ready to receive HTTP requests. In a couple of lines, we have a fully operational application. Actix takes care of the low level boilerplate for us.

```rust title="Annotation"
#[get("/tweets")]
```

Annotation is a very convenient way to bind a route to the right path.


### Validation

Let's run our application:

```bash title="Run our application"
# Go inside the root project directory
$ cd twitter-clone-rust

# Run the application
$ cargo run
```

And validate that each endpoint with no errors:

```bash title="Curl commands to test our API"
# list tweets
curl http://localhost:9090/tweets

# get a tweet (return status code: 204 because there is no tweet)
curl http://localhost:9090/tweets/abc

# create a tweet
curl -X POST -d '{"message": "This is a tweet"}' -H "Content-type: application/json" http://localhost:9090/tweets

# delete a tweet (return status code: 204 in any case)
curl -X DELETE http://localhost:9090/tweets/abc

# list likes from a tweet
curl http://localhost:9090/tweets/abc/likes

# add one like to a tweet
curl -X POST http://localhost:9090/tweets/abc/likes

# remove one like to a tweet
curl -X DELETE http://localhost:9090/tweets/abc/likes
```

At this stage, our application works without any database. Let's go more in-depth and connect it to PostgreSQL.

## PostgreSQL

### Diesel

[Diesel](https://diesel.rs/) is the most popular ORM in Rust to connect to a [PostgreSQL][urls.postgresql] database. Combined with Actix, it's a perfect fit to persist in our data. Let's see how we can make that happen. However, Diesel does not support [tokio](https://github.com/tokio-rs/tokio) (the asynchronous engine behind Actix), so we have to run it in separate threads using the web::block function, which offloads blocking code (like Diesel's) to do not block the server's thread.

<Alert type="warning">

Read the Diesel [Getting started](http://diesel.rs/guides/getting-started/) to generate tables configurations.

</Alert>

```rust title="schema.rs"
table! {
    likes (id) {
        id -> Uuid,
        created_at -> Timestamp,
        tweet_id -> Uuid,
    }
}

table! {
    tweets (id) {
        id -> Uuid,
        created_at -> Timestamp,
        message -> Text,
    }
}

joinable!(likes -> tweets (tweet_id));

allow_tables_to_appear_in_same_query!(
    likes,
    tweets,
);
```

Diesel uses a macro `table!...` and an internal DSL to declare the structure of our tables. There is no magic here. The code is compiled and statically linked at the compilation.

<Tabs
  centered={false}
  className={"square"}
  defaultValue={"main.rs"}
  select={false}
  size={null}
  values={[{"group":"Files","label":"main.rs","value":"main.rs"},{"group":"Files","label":"tweet.rs","value":"tweet.rs"},{"group":"Files","label":"like.rs","value":"like.rs"}]}>

<TabItem value="main.rs">

```rust title="main.rs" {6-11,15-16}
#[actix_rt::main]
async fn main() -> io::Result<()> {
    env::set_var("RUST_LOG", "actix_web=debug,actix_server=info");
    env_logger::init();

    // set up database connection pool
    let database_url = env::var("DATABASE_URL").expect("DATABASE_URL");
    let manager = ConnectionManager::<PgConnection>::new(database_url);
    let pool = r2d2::Pool::builder()
        .build(manager)
        .expect("Failed to create pool");

    HttpServer::new(move || {
        App::new()
            // Set up DB pool to be used with web::Data<Pool> extractor
            .data(pool.clone())
            // enable logger - always register actix-web Logger middleware last
            .wrap(middleware::Logger::default())
            // register HTTP requests handlers
            .service(tweet::list)
            .service(tweet::get)
            .service(tweet::create)
            .service(tweet::delete)
            .service(like::list)
            .service(like::plus_one)
            .service(like::minus_one)
    })
    .bind("0.0.0.0:9090")?
    .run()
    .await
}
```

[main.rs source code](https://github.com/evoxmusic/twitter-clone-rust/blob/master/src/main.rs)

</TabItem>

<TabItem value="tweet.rs">

```rust title="tweet.rs"
//...
fn list_tweets(total_tweets: i64, conn: &DBPooledConnection) -> Result<Tweets, Error> {
    use crate::schema::tweets::dsl::*;

    let _tweets = match tweets
        .order(created_at.desc())
        .limit(total_tweets)
        .load::<TweetDB>(conn)
    {
        Ok(tws) => tws,
        Err(_) => vec![],
    };

    Ok(Tweets {
        results: _tweets
            .into_iter()
            .map(|t| t.to_tweet())
            .collect::<Vec<Tweet>>(),
    })
}

fn find_tweet(_id: Uuid, conn: &DBPooledConnection) -> Result<Tweet, Error> {
    use crate::schema::tweets::dsl::*;

    let res = tweets.filter(id.eq(_id)).load::<TweetDB>(conn);
    match res {
        Ok(tweets_db) => match tweets_db.first() {
            Some(tweet_db) => Ok(tweet_db.to_tweet()),
            _ => Err(Error::NotFound),
        },
        Err(err) => Err(err),
    }
}

fn create_tweet(tweet: Tweet, conn: &DBPooledConnection) -> Result<Tweet, Error> {
    use crate::schema::tweets::dsl::*;

    let tweet_db = tweet.to_tweet_db();
    let _ = diesel::insert_into(tweets).values(&tweet_db).execute(conn);

    Ok(tweet_db.to_tweet())
}

fn delete_tweet(_id: Uuid, conn: &DBPooledConnection) -> Result<(), Error> {
    use crate::schema::tweets::dsl::*;

    let res = diesel::delete(tweets.filter(id.eq(_id))).execute(conn);
    match res {
        Ok(_) => Ok(()),
        Err(err) => Err(err),
    }
}
//...
```

[tweet.rs source code](https://github.com/evoxmusic/twitter-clone-rust/blob/master/src/tweet.rs)

</TabItem>

<TabItem value="like.rs">

```rust title="like.rs"
//...
pub fn list_likes(_tweet_id: Uuid, conn: &DBPooledConnection) -> Result<Likes, Error> {
    use crate::schema::likes::dsl::*;

    let _likes: Vec<LikeDB> = match likes
        .filter(tweet_id.eq(_tweet_id))
        .order(created_at.desc())
        .load::<LikeDB>(conn)
    {
        Ok(lks) => lks,
        Err(_) => vec![],
    };

    Ok(Likes {
        results: _likes
            .into_iter()
            .map(|l| l.to_like())
            .collect::<Vec<Like>>(),
    })
}

pub fn create_like(_tweet_id: Uuid, conn: &DBPooledConnection) -> Result<Like, Error> {
    use crate::schema::likes::dsl::*;

    let like = Like::new();
    let _ = diesel::insert_into(likes)
        .values(like.to_like_db(_tweet_id))
        .execute(conn);

    Ok(like)
}

pub fn delete_like(_tweet_id: Uuid, conn: &DBPooledConnection) -> Result<(), Error> {
    use crate::schema::likes::dsl::*;

    let _likes = list_likes(_tweet_id, conn);

    let like = match &_likes {
        Ok(_likes) if !_likes.results.is_empty() => _likes.results.first(),
        _ => None,
    };

    if like.is_none() {
        return Ok(());
    }

    let like_id = Uuid::from_str(like.unwrap().id.as_str()).unwrap();

    let res = diesel::delete(likes.filter(id.eq(like_id))).execute(conn);
    match res {
        Ok(_) => Ok(()),
        Err(err) => Err(err),
    }
}
//...
```

[like.rs source code](https://github.com/evoxmusic/twitter-clone-rust/blob/master/src/like.rs)

</TabItem>

</Tabs>

## Deployment

Qovery is going to help you to deploy your application in a few seconds. Let's deploy our Twitter Clone now.

<Tabs
  centered={true}
  className={"rounded"}
  defaultValue={"web"}
  placeholder="Select your interface"
  select={false}
  size={null}
  values={[{"group":"Interfaces","label":"Web","value":"web"},{"group":"Interfaces","label":"CLI","value":"cli"}]}>

<TabItem value="web">

<li>

Sign in to the [Qovery web interface][urls.start_qovery].

<p align="center">
  <a href="https://console.qovery.com/"><img src="/img/Qovery_Sign_Up_Page.png" alt="Qovery Sign-up page" /></a>
</p>

</li>

</TabItem>

<TabItem value="cli">

<li>

### Install Qovery CLI

<Tabs
  centered={true}
  className={"rounded"}
  defaultValue={"linux"}
  placeholder="Select your OS"
  select={false}
  size={null}
  values={[{"group":"Platforms","label":"Linux","value":"linux"},{"group":"Platforms","label":"MacOS","value":"macos"},{"group":"Platforms","label":"Windows","value":"windows"},{"group": "Platforms","label":"Docker","value":"docker"}]}>

<TabItem value="linux">

<Tabs
  centered={true}
  className="rounded"
  defaultValue="universal"
  values={[{"label":"*nix","value":"universal"},{"label":"Arch Linux","value":"arch"},{"label":"Manual","value":"manual"}]}>

<TabItem value="universal">

To download and install Qovery CLI on any Linux distribution:
```bash
$ curl -s https://get.qovery.com | bash
```

</TabItem>
<TabItem value="arch">

Qovery is part of [AUR](https://aur.archlinux.org/packages) packages, so you can install it with [yay](https://github.com/Jguer/yay):

```bash
$ yay qovery-cli
```

</TabItem>
<TabItem value="manual">

Install the Qovery CLI on Linux manually by downloading the [latest release][urls.qovery_cli_releases], and uncompress its content to a folder into your shell `PATH`.

</TabItem>
</Tabs>
</TabItem>

<TabItem value="macos">

<Tabs
  centered={true}
  className="rounded"
  defaultValue="homebrew"
  values={[{"label":"Homebrew","value":"homebrew"},{"label":"Script","value":"script"},{"label":"Manual","value":"manual"}]}>

<TabItem value="homebrew">

The common solution to install a command line binary on the MacOS is to use [Homebrew][urls.brew].

```bash
# Add Qovery brew repository
$ brew tap Qovery/qovery-cli

# Install the CLI
$ brew install qovery-cli
```

</TabItem>

<TabItem value="script">

To download and install Qovery CLI from the command line:
```bash
$ curl -s https://get.qovery.com | bash
```

</TabItem>

<TabItem value="manual">

Install the Qovery CLI on Mac OS manually by downloading the [latest release][urls.qovery_cli_releases], and uncompress its content to a folder into your shell `PATH`.

</TabItem>

</Tabs>

</TabItem>

<TabItem value="windows">

<Tabs
  centered={true}
  className="rounded"
  defaultValue="scoop"
  values={[{"label":"Scoop","value":"scoop"},{"label":"Manual","value":"manual"}]}>

<TabItem value="scoop">

The classic way to install binaries on Windows is to use [Scoop][urls.scoop].

```bash
# Add Qovery bucket
$ scoop bucket add qovery https://github.com/Qovery/scoop-qovery-cli

# Install the CLI
$ scoop install qovery-cli
```

</TabItem>

<TabItem value="manual">

Install the Qovery CLI on Windows manually by downloading the [latest release][urls.qovery_cli_releases], and uncompress its content to
`C:\Windows`.

</TabItem>

</Tabs>

</TabItem>


<TabItem value="docker">

Install Docker on your local machine and run the following command:

```bash
# Pull and Run the latest Qovery CLI
$ docker run ghcr.io/qovery/qovery-cli:latest help
```

Change `latest` by the version you want to use. For example, to use the version 0.58.4, run:

```bash
$ docker run ghcr.io/qovery/qovery-cli:0.58.4 help
```

Note: `ghcr.io` is the [GitHub Container Registry](https://github.com/Qovery/qovery-cli/pkgs/container/qovery-cli).

</TabItem>

</Tabs>

</li>

<li>

### Sign up

```bash
# Sign up and sign in command
$ qovery auth
```

<Alert type="info">

If you are using a headless (without GUI) environment, you can use the following command to sign up and sign in:

```bash
# Sign up and sign in command
$ qovery auth --headless
```

</Alert>

Your browser window with Qovery sign-up page will open. Follow the instructions to sign up and sign in.

</li>

</TabItem>

</Tabs>

### Deploying the app

<Steps headingDepth={3}>
<ol>
<li>

### Create a new project

<p align="center">
  <img src="/img/heroku/heroku-2.png" alt="Migrate from Heroku" />
</p>

</li>

<li>

### Create a new environment

<p align="center">
  <img src="/img/heroku/heroku-3.png" alt="Migrate from Heroku" />
</p>

</li>

<li>

### Create a new application

To follow the guide, <a href="https://github.com/evoxmusic/twitter-clone-rust">you can fork and use our repository</a>

Use the forked repository (and branch **master**) while creating the application in the repository field:

<p align="center">
  <img src="/img/rust/rust.png" alt="Migrate from Heroku" />
</p>

</li>

<li>

After the application is created: 

- Navigate application settings
- Select **Port**
- Add port **9090**

<p align="left">
    <img src="/img/micro/micros-1.png" alt="Microservices" />
</p>

</li>

<li>

### Deploy a database

Create and deploy a new database

<Alert type="warning">

Name the database **my-pql-db** to follow the guide flawlessly

</Alert>

To learn how to do it, you can [follow this guide][guides.getting-started.create-a-database]

</li>

<li>

### Configure the connection to the database

In application overview, open the **Variables** tab

<p align="center">
  <img src="/img/open-env-var.png" alt="Open Variable" />
</p>

Configure the alias for each built_in environment variable to match the one required within your code

<p align="center">
  <img src="/img/alias.png" alt="Env Var Alias" />
</p>

Have a look at [this section][docs.using-qovery.configuration.environment-variable#connecting-to-a-database] to know more on how to connect to a database.

</li>

## Deploy your application

All you have to do now is to navigate to your application and click **Deploy** button

<p align="center">
  <img src="/img/heroku/heroku-1.png" alt="Deploy App" />
</p>

That's it. Watch the status and wait till the app is deployed.

</ol>
</Steps>

Congratulations, you have deployed your application!

## Live test

To open the application in your browser, click on **Action** and **Open** buttons in your application overview:

<p align="center">
  <img src="/img/deploy-env-1.png" alt="Open App" />
</p>

Then, we can test it with the following CURL commands (replace the app URL with your own):

```bash title="Curl commands to test our deployed API"
# create a tweet
curl -X POST -d '{"message": "This is a tweet"}' -H "Content-type: application/json" https://main-gxbuagyvgnkbrp5l-gtw.qovery.io/tweets

# list tweets
curl https://main-gxbuagyvgnkbrp5l-gtw.qovery.io/tweets

# get a tweet
curl https://main-gxbuagyvgnkbrp5l-gtw.qovery.io/tweets/<change_with_a_valid_id>

# list likes from a tweet
curl https://main-gxbuagyvgnkbrp5l-gtw.qovery.io/tweets/<change_with_a_valid_id>/likes

# add one like to a tweet
curl -X POST https://main-gxbuagyvgnkbrp5l-gtw.qovery.io/tweets/<change_with_a_valid_id>/likes

# remove one like to a tweet
curl -X DELETE https://main-gxbuagyvgnkbrp5l-gtw.qovery.io/tweets/<change_with_a_valid_id>/likes

# delete a tweet
curl -X DELETE https://main-gxbuagyvgnkbrp5l-gtw.qovery.io/tweets/<change_with_a_valid_id>
```

<Alert type="info">

You can [add your custom domain][guides.getting-started.setting-custom-domain]

</Alert>

## What's next

In this first part we saw how to create a Rust API with Actix and Diesel. In the second part we will compare its performance with a Go application to see which one is the most performant.

**Special thanks to [Jason](https://twitter.com/imjasonmiller) and [Kokou](https://twitter.com/doctor_code) for your reviews**

## Useful resources

* [Source code](https://github.com/evoxmusic/twitter-clone-rust)

Do you want to know more about Rust?
* [A great blog to follow along with Rust development](https://blog.rust-lang.org/inside-rust/)
* [Jon Gjengset](https://www.youtube.com/channel/UC_iD0xppBwwsrM9DegC5cQQ) - PhD student at MIT in distributed systems and Rust live-coder
* [The Rust programming language book](https://doc.rust-lang.org/book/) (Free)
* [My first service in Rust](https://www.youtube.com/watch?v=j_4sadjjWh8) (French video - François T.)

<Jump to="/guides/tutorial/">Tutorial</Jump>


[docs.using-qovery.configuration.environment-variable#connecting-to-a-database]: /docs/using-qovery/configuration/environment-variable/#connecting-to-a-database
[guides.getting-started.create-a-database]: /guides/getting-started/create-a-database/
[guides.getting-started.setting-custom-domain]: /guides/getting-started/setting-custom-domain/
[urls.brew]: https://brew.sh/
[urls.postgresql]: https://www.postgresql.org
[urls.qovery_cli_releases]: https://github.com/Qovery/qovery-cli/releases
[urls.scoop]: https://scoop.sh/
[urls.start_qovery]: https://start.qovery.com

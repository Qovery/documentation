---
$schema: "/.meta/.schemas/guides.json"
title: Create a blazingly fast REST API in Rust (Part 1/2)
description: How to create a blazingly fast REST API in Rust, with zero-cost abstraction and very low overhead - Part 1/2
author_github: https://github.com/evoxmusic
tags: ["type: tutorial", "language: rust"]
hide_pagination: true
---
import Alert from '@site/src/components/Alert';
import Assumptions from '@site/src/components/Assumptions';
import Jump from '@site/src/components/Jump';

> [Fast, reliable, productive - Pick three](https://github.com/rust-lang/www.rust-lang.org/issues/419#issuecomment-443418587) | Rust's slogan

Rust is a systems programming language that runs blazingly fast, prevents segfaults, and guarantees thread safety. Coupled with Actix, I should be able to build a fast REST API elegantly.

The idea behind this article is to see how performant a Rust API can be. I am going to create an API that saves and reads data from/to a PostgreSQL database.

<Alert type="info">

Most of the Rust REST API tests across the web are "[Hello World](https://medium.com/sean3z/rest-api-node-vs-rust-c75aa8c96343)" applications. They bench direct API I/O with no payload. It's very far from reality. In the part 2 of this article, I will bench our Rust application with an intensive payload.

</Alert>

This article is separate in two parts, in this first part you will learn how to:

* Create a blazingly fast REST API in Rust
* Connect it to a PostgreSQL database

In the second part, we will compare the performance of our application to a Go application.

## Twitter clone

> [Twitter](https://www.twitter.com) is a "microblogging" system that allows people to send and receive short posts called tweets.

Let's create a small part of the Twitter API to be able to post, read, and like tweets. The goal is to be able to use our Twitter clone with a massive number of simultaneous fake users.

<Assumptions>

* You have installed [Cargo](https://github.com/rust-lang/cargo) (Rust package manager)

</Assumptions>

### API design

Our REST API needs to have three endpoints :

* **/tweets**
  * GET: list last 50 tweets
  * POST: create a new tweet
* **/tweets/:id**
  * GET: find a tweet by its ID
  * DELETE: delete a tweet by its ID
* **/tweets/:id/likes**
  * GET: list all likes attached to a tweet
  * POST: add +1 like to a tweet
  * DELETE: add -1 like to a tweet

<Alert type="info">

For the sake of simplicity, I will not set up a user management service.

</Alert>

## Implementation

Even though implementing an HTTP server could be fun, I choose to use [Actix](https://actix.rs/), which is ranked as [the most performant framework](https://www.techempower.com/benchmarks/#section=data-r18&hw=ph&test=fortune) ever by *Techempower*.

### Actix Web

Actix is an actor framework prevalent in the Rust ecosystem. I am using it as an HTTP server to build our REST API.

### Let's code

Three files structured our application.
* `main.rs` to route HTTP requests to the right endpoint
* `tweet.rs` to handle requests on /tweets
* `like.rs` to handle requests on /tweets/:id/likes

<Tabs
  centered={false}
  className={"square"}
  defaultValue={"main.rs"}
  select={false}
  size={null}
  values={[{"group":"Files","label":"main.rs","value":"main.rs"},{"group":"Files","label":"tweet.rs","value":"tweet.rs"},{"group":"Files","label":"like.rs","value":"like.rs"}]}>

<TabItem value="main.rs">

```rust title="main.rs"
#[actix_rt::main]
async fn main() -> io::Result<()> {
    env::set_var("RUST_LOG", "actix_web=debug,actix_server=info");
    env_logger::init();

    HttpServer::new(|| {
        App::new()
            // enable logger - always register actix-web Logger middleware last
            .wrap(middleware::Logger::default())
            // register HTTP requests handlers
            .service(tweet::list)
            .service(tweet::get)
            .service(tweet::create)
            .service(tweet::delete)
            .service(like::list)
            .service(like::plus_one)
            .service(like::minus_one)
    })
    .bind("0.0.0.0:9090")?
    .run()
    .await
}
```

[main.rs source code](https://github.com/evoxmusic/twitter-clone-rust/blob/487198ee7b306f36dbab01f40a44345f85387db2/src/main.rs)

</TabItem>

<TabItem value="tweet.rs">

```rust title="tweet.rs"
pub type Tweets = Response<Tweet>;

#[derive(Debug, Deserialize, Serialize)]
pub struct Tweet {
    pub id: String,
    pub created_at: DateTime<Utc>,
    pub message: String,
    pub likes: Vec<Like>,
}

impl Tweet {
    pub fn new(message: String) -> Self {
        Self {
            id: Uuid::new_v4().to_string(),
            created_at: Utc::now(),
            message,
            likes: vec![],
        }
    }
}

#[derive(Debug, Deserialize, Serialize)]
pub struct TweetRequest {
    pub message: Option<String>,
}

impl TweetRequest {
    pub fn to_tweet(&self) -> Option<Tweet> {
        match &self.message {
            Some(message) => Some(Tweet::new(message.to_string())),
            None => None,
        }
    }
}

/// list 50 last tweets `/tweets`
#[get("/tweets")]
pub async fn list() -> HttpResponse {
    // TODO find the last 50 tweets and return them

    let tweets = Tweets { results: vec![] };

    HttpResponse::Ok()
        .content_type(APPLICATION_JSON)
        .json(tweets)
}

/// create a tweet `/tweets`
#[post("/tweets")]
pub async fn create(tweet_req: Json<TweetRequest>) -> HttpResponse {
    HttpResponse::Created()
        .content_type(APPLICATION_JSON)
        .json(tweet_req.to_tweet())
}

/// find a tweet by its id `/tweets/{id}`
#[get("/tweets/{id}")]
pub async fn get(path: Path<(String,)>) -> HttpResponse {
    // TODO find tweet a tweet by ID and return it
    let found_tweet: Option<Tweet> = None;

    match found_tweet {
        Some(tweet) => HttpResponse::Ok()
            .content_type(APPLICATION_JSON)
            .json(tweet),
        None => HttpResponse::NoContent()
            .content_type(APPLICATION_JSON)
            .await
            .unwrap(),
    }
}

/// delete a tweet by its id `/tweets/{id}`
#[delete("/tweets/{id}")]
pub async fn delete(path: Path<(String,)>) -> HttpResponse {
    // TODO delete tweet by ID
    // in any case return status 204

    HttpResponse::NoContent()
        .content_type(APPLICATION_JSON)
        .await
        .unwrap()
}
```

[tweet.rs source code](https://github.com/evoxmusic/twitter-clone-rust/blob/487198ee7b306f36dbab01f40a44345f85387db2/src/tweet.rs)

</TabItem>

<TabItem value="like.rs">

```rust title="like.rs"
pub type Likes = Response<Like>;

#[derive(Debug, Deserialize, Serialize)]
pub struct Like {
    pub id: String,
    pub created_at: DateTime<Utc>,
}

impl Like {
    pub fn new() -> Self {
        Self {
            id: Uuid::new_v4().to_string(),
            created_at: Utc::now(),
        }
    }
}

/// list last 50 likes from a tweet `/tweets/{id}/likes`
#[get("/tweets/{id}/likes")]
pub async fn list(path: Path<(String,)>) -> HttpResponse {
    // TODO find likes by tweet ID and return them
    let likes = Likes { results: vec![] };

    HttpResponse::Ok()
        .content_type(APPLICATION_JSON)
        .json(likes)
}

/// add one like to a tweet `/tweets/{id}/likes`
#[post("/tweets/{id}/likes")]
pub async fn plus_one(path: Path<(String,)>) -> HttpResponse {
    // TODO add one like to a tweet
    let like = Like::new();

    HttpResponse::Created()
        .content_type(APPLICATION_JSON)
        .json(like)
}

/// remove one like from a tweet `/tweets/{id}/likes`
#[delete("/tweets/{id}/likes")]
pub async fn minus_one(path: Path<(String,)>) -> HttpResponse {
    // TODO remove one like to a tweet
    HttpResponse::NoContent()
        .content_type(APPLICATION_JSON)
        .await
        .unwrap()
}
```

[like.rs source code](https://github.com/evoxmusic/twitter-clone-rust/blob/487198ee7b306f36dbab01f40a44345f85387db2/src/like.rs)

</TabItem>

</Tabs>

With only these three files, our application is ready to receive HTTP requests. In a couple of lines, we have a fully operational application. Actix takes care of the low level boilerplate for us.

```rust title="Annotation"
#[get("/tweets")]
```

Annotation is a very convenient way to bind a route to the right path.


### Validation

Let's run our application:

```bash title="Run our application"
# Go inside the root project directory
$ cd twitter-clone-rust

# Run the application
$ cargo run
```

And validate that each endpoint with no errors:

```bash title="Curl commands to test our API"
# list tweets
curl http://localhost:9090/tweets

# get a tweet (return status code: 204 because there is no tweet)
curl http://localhost:9090/tweets/abc

# create a tweet
curl -X POST -d '{"message": "This is a tweet"}' -H "Content-type: application/json" http://localhost:9090/tweets

# delete a tweet (return status code: 204 in any case)
curl -X DELETE http://localhost:9090/tweets/abc

# list likes from a tweet
curl http://localhost:9090/tweets/abc/likes

# add one like to a tweet
curl -X POST http://localhost:9090/tweets/abc/likes

# remove one like to a tweet
curl -X DELETE http://localhost:9090/tweets/abc/likes
```

At this stage, our application works without any database. Let's go more in-depth and connect it to PostgreSQL.

## PostgreSQL

### Diesel

[Diesel](https://diesel.rs/) is the most popular ORM in Rust to connect to a [PostgreSQL][urls.postgresql] database. Combined with Actix, it's a perfect fit to persist in our data. Let's see how we can make that happen. However, Diesel does not support [tokio](https://github.com/tokio-rs/tokio) (the asynchronous engine behind Actix), so we have to run it in separate threads using the web::block function, which offloads blocking code (like Diesel's) to do not block the server's thread.

<Alert type="warning">

Read the Diesel [Getting started](http://diesel.rs/guides/getting-started/) to generate tables configurations.

</Alert>

```rust title="schema.rs"
table! {
    likes (id) {
        id -> Uuid,
        created_at -> Timestamp,
        tweet_id -> Uuid,
    }
}

table! {
    tweets (id) {
        id -> Uuid,
        created_at -> Timestamp,
        message -> Text,
    }
}

joinable!(likes -> tweets (tweet_id));

allow_tables_to_appear_in_same_query!(
    likes,
    tweets,
);
```

Diesel uses a macro `table!...` and an internal DSL to declare the structure of our tables. There is no magic here. The code is compiled and statically linked at the compilation.

<Tabs
  centered={false}
  className={"square"}
  defaultValue={"main.rs"}
  select={false}
  size={null}
  values={[{"group":"Files","label":"main.rs","value":"main.rs"},{"group":"Files","label":"tweet.rs","value":"tweet.rs"},{"group":"Files","label":"like.rs","value":"like.rs"}]}>

<TabItem value="main.rs">

```rust title="main.rs" {6-11,15-16}
#[actix_rt::main]
async fn main() -> io::Result<()> {
    env::set_var("RUST_LOG", "actix_web=debug,actix_server=info");
    env_logger::init();

    // set up database connection pool
    let database_url = env::var("DATABASE_URL").expect("DATABASE_URL");
    let manager = ConnectionManager::<PgConnection>::new(database_url);
    let pool = r2d2::Pool::builder()
        .build(manager)
        .expect("Failed to create pool");

    HttpServer::new(move || {
        App::new()
            // Set up DB pool to be used with web::Data<Pool> extractor
            .data(pool.clone())
            // enable logger - always register actix-web Logger middleware last
            .wrap(middleware::Logger::default())
            // register HTTP requests handlers
            .service(tweet::list)
            .service(tweet::get)
            .service(tweet::create)
            .service(tweet::delete)
            .service(like::list)
            .service(like::plus_one)
            .service(like::minus_one)
    })
    .bind("0.0.0.0:9090")?
    .run()
    .await
}
```

[main.rs source code](https://github.com/evoxmusic/twitter-clone-rust/blob/master/src/main.rs)

</TabItem>

<TabItem value="tweet.rs">

```rust title="tweet.rs"
//...
fn list_tweets(total_tweets: i64, conn: &DBPooledConnection) -> Result<Tweets, Error> {
    use crate::schema::tweets::dsl::*;

    let _tweets = match tweets
        .order(created_at.desc())
        .limit(total_tweets)
        .load::<TweetDB>(conn)
    {
        Ok(tws) => tws,
        Err(_) => vec![],
    };

    Ok(Tweets {
        results: _tweets
            .into_iter()
            .map(|t| t.to_tweet())
            .collect::<Vec<Tweet>>(),
    })
}

fn find_tweet(_id: Uuid, conn: &DBPooledConnection) -> Result<Tweet, Error> {
    use crate::schema::tweets::dsl::*;

    let res = tweets.filter(id.eq(_id)).load::<TweetDB>(conn);
    match res {
        Ok(tweets_db) => match tweets_db.first() {
            Some(tweet_db) => Ok(tweet_db.to_tweet()),
            _ => Err(Error::NotFound),
        },
        Err(err) => Err(err),
    }
}

fn create_tweet(tweet: Tweet, conn: &DBPooledConnection) -> Result<Tweet, Error> {
    use crate::schema::tweets::dsl::*;

    let tweet_db = tweet.to_tweet_db();
    let _ = diesel::insert_into(tweets).values(&tweet_db).execute(conn);

    Ok(tweet_db.to_tweet())
}

fn delete_tweet(_id: Uuid, conn: &DBPooledConnection) -> Result<(), Error> {
    use crate::schema::tweets::dsl::*;

    let res = diesel::delete(tweets.filter(id.eq(_id))).execute(conn);
    match res {
        Ok(_) => Ok(()),
        Err(err) => Err(err),
    }
}
//...
```

[tweet.rs source code](https://github.com/evoxmusic/twitter-clone-rust/blob/master/src/tweet.rs)

</TabItem>

<TabItem value="like.rs">

```rust title="like.rs"
//...
pub fn list_likes(_tweet_id: Uuid, conn: &DBPooledConnection) -> Result<Likes, Error> {
    use crate::schema::likes::dsl::*;

    let _likes: Vec<LikeDB> = match likes
        .filter(tweet_id.eq(_tweet_id))
        .order(created_at.desc())
        .load::<LikeDB>(conn)
    {
        Ok(lks) => lks,
        Err(_) => vec![],
    };

    Ok(Likes {
        results: _likes
            .into_iter()
            .map(|l| l.to_like())
            .collect::<Vec<Like>>(),
    })
}

pub fn create_like(_tweet_id: Uuid, conn: &DBPooledConnection) -> Result<Like, Error> {
    use crate::schema::likes::dsl::*;

    let like = Like::new();
    let _ = diesel::insert_into(likes)
        .values(like.to_like_db(_tweet_id))
        .execute(conn);

    Ok(like)
}

pub fn delete_like(_tweet_id: Uuid, conn: &DBPooledConnection) -> Result<(), Error> {
    use crate::schema::likes::dsl::*;

    let _likes = list_likes(_tweet_id, conn);

    let like = match &_likes {
        Ok(_likes) if !_likes.results.is_empty() => _likes.results.first(),
        _ => None,
    };

    if like.is_none() {
        return Ok(());
    }

    let like_id = Uuid::from_str(like.unwrap().id.as_str()).unwrap();

    let res = diesel::delete(likes.filter(id.eq(like_id))).execute(conn);
    match res {
        Ok(_) => Ok(()),
        Err(err) => Err(err),
    }
}
//...
```

[like.rs source code](https://github.com/evoxmusic/twitter-clone-rust/blob/master/src/like.rs)

</TabItem>

</Tabs>

## Deployment

Qovery is going to help you to deploy your application in a few seconds. Let's deploy our Twitter Clone now.

<%= qovery_sign_up() %>

Qovery needs two files at the root of your project to deploy an application:

* `.qovery.yml` to declare the dependencies that your application need (E.g PostgreSQL).
* `Dockerfile` to build and run your application.

<Tabs
  centered={false}
  className={"square"}
  defaultValue={".qovery.yml"}
  select={false}
  size={null}
  values={[{"group":"Files","label":".qovery.yml","value":".qovery.yml"},{"group":"Files","label":"Dockerfile","value":"Dockerfile"}]}>

<TabItem value=".qovery.yml">

```bash title=".qovery.yml"
application:
  name: twitter-clone-rust
  project: Twitter-Clone
  publicly_accessible: true
databases:
- type: postgresql
  version: "11.5"
  name: my-postgresql-8628210
routers:
- name: main
  routes:
  - application_name: twitter-clone-rust
    paths:
    - /
```

</TabItem>

<TabItem value="Dockerfile">

```bash title="Dockerfile"
# build stage
FROM rust:latest as cargo-build

RUN apt-get update && apt-get install musl-tools -y
RUN rustup target add x86_64-unknown-linux-musl

WORKDIR /usr/src/app
COPY . .

RUN RUSTFLAGS=-Clinker=musl-gcc cargo build --release --target=x86_64-unknown-linux-musl

###################
# final stage
FROM alpine:latest

RUN addgroup -g 1000 app
RUN adduser -D -s /bin/sh -u 1000 -G app app

WORKDIR /home/app/bin/
COPY --from=cargo-build /usr/src/app/target/x86_64-unknown-linux-musl/release/twitter-clone-rust .

RUN chown app:app twitter-clone-rust
USER app

EXPOSE 9090

CMD ["./twitter-clone-rust"]
```

</TabItem>

</Tabs>

Now, commit and push your `.qovery.yml` and `Dockerfile`:

```bash title="Git commit and push"
$ git add .qovery.yml Dockerfile
$ git commit -m "add .qovery.yml Dockerfile"
$ git push -u origin master
```

```bash title="Create DATABASE_URL env var"
$ qovery project env add DATABASE_URL '$QOVERY_DATABASE_MY_POSTGRESQL_8628210_CONNECTION_URI'
```

Congratulations, you have deployed your application.

## Live test

To test our deployed API, execute the following command to find your API root URL:

```bash title="Get our API root URL"
$ qovery status
```

```bash title="Output"
BRANCH NAME | STATUS  | ENDPOINTS                                   | APPLICATIONS       | DATABASES
master      | running | https://main-gxbuagyvgnkbrp5l-gtw.qovery.io | twitter-clone-rust | my-postgresql-8628210

APPLICATION NAME   | STATUS  | DATABASES
twitter-clone-rust | running | my-postgresql-8628210

DATABASE NAME         | STATUS  | TYPE       | VERSION | ENDPOINT | PORT     | USERNAME | PASSWORD | APPLICATIONS
my-postgresql-8628210 | running | POSTGRESQL | 11.5    | <hidden> | <hidden> | <hidden> | <hidden> | twitter-clone-rust
```

Then, we can test it with the following CURL commands:

```bash title="Curl commands to test our deployed API"
# create a tweet
curl -X POST -d '{"message": "This is a tweet"}' -H "Content-type: application/json" https://main-gxbuagyvgnkbrp5l-gtw.qovery.io/tweets

# list tweets
curl https://main-gxbuagyvgnkbrp5l-gtw.qovery.io/tweets

# get a tweet
curl https://main-gxbuagyvgnkbrp5l-gtw.qovery.io/tweets/<change_with_a_valid_id>

# list likes from a tweet
curl https://main-gxbuagyvgnkbrp5l-gtw.qovery.io/tweets/<change_with_a_valid_id>/likes

# add one like to a tweet
curl -X POST https://main-gxbuagyvgnkbrp5l-gtw.qovery.io/tweets/<change_with_a_valid_id>/likes

# remove one like to a tweet
curl -X DELETE https://main-gxbuagyvgnkbrp5l-gtw.qovery.io/tweets/<change_with_a_valid_id>/likes

# delete a tweet
curl -X DELETE https://main-gxbuagyvgnkbrp5l-gtw.qovery.io/tweets/<change_with_a_valid_id>
```

<Alert type="info">

You can [add your custom domain][docs.domains]

</Alert>

## What's next

In this first part we saw how to create a Rust API with Actix and Diesel. In the second part we will compare its performance with a Go application to see which one is the most performant.

**Special thanks to [Jason](https://twitter.com/imjasonmiller) and [Kokou](https://twitter.com/doctor_code) for your reviews**

## Useful resources

* [Source code](https://github.com/evoxmusic/twitter-clone-rust)

Do you want to know more about Rust?
* [A great blog to follow along with Rust development](https://blog.rust-lang.org/inside-rust/)
* [Jon Gjengset](https://www.youtube.com/channel/UC_iD0xppBwwsrM9DegC5cQQ) - PhD student at MIT in distributed systems and Rust live-coder
* [The Rust programming language book](https://doc.rust-lang.org/book/) (Free)
* [My first service in Rust](https://www.youtube.com/watch?v=j_4sadjjWh8) (French video - Fran√ßois T.)

<Jump to="/guides/tutorial/">Tutorial</Jump>

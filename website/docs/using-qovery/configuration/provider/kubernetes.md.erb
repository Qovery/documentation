---
last_modified_on: "2023-11-25"
title: "Kubernetes"
description: "Learn how to install and configure Qovery on your own Kubernetes cluster (BYOK) / Self-managed Kubernetes cluster"
---

import Steps from '@site/src/components/Steps';
import Alert from '@site/src/components/Alert';
import Assumptions from '@site/src/components/Assumptions';

<Alert type="warning">

Installing Qovery on your Kubernetes cluster is currently in beta. [You need to request your access here](https://www.qovery.com/solutions/bring-your-own-kubernetes).

</Alert>

<Alert type="info">

This section is for Kubernetes power-users. If you are not familiar with Kubernetes, we recommend you to use Qovery on a Managed Kubernetes cluster on [AWS][docs.using-qovery.configuration.cloud-service-provider.amazon-web-services], [GCP][docs.using-qovery.configuration.cloud-service-provider.google-cloud-platform], [Scaleway][docs.using-qovery.configuration.cloud-service-provider.microsoft-azure], or contact us.

</Alert>

Qovery Self-Managed or BYOK (Bring Your Own Kubernetes) is a self-hosted version of Qovery. It allows you to install Qovery on your own Kubernetes cluster.
Read [this article](https://www.qovery.com/blog/kubernetes-managed-by-qovery-vs-self-managed-byok) to better understand the difference with the Managed Kubernetes by Qovery. In a nutshell, Qovery Managed/BYOK is for Kubernetes experts who want to manage their own Kubernetes cluster.
In this version, Qovery does not manage the Kubernetes cluster for you.

This page explains how to install and configure Qovery on your Kubernetes cluster. If you are looking for a quick step-by-step guide, please follow the [Kubernetes guide][guides.provider.guide-kubernetes].

## Components

<p align="center">
  <img src="/img/qovery_byok_how_it_works.jpg" alt="How Qovery works with Self Managed Kubernetes cluster" />
</p>

They are two types of components:

Qovery components:
- Qovery Control Plane: the Qovery Control Plane is the brain of Qovery. It is responsible for managing your applications and providing the API to interact with Qovery.
- Qovery Engine: the Qovery Engine is responsible for managing your applications on your Kubernetes cluster. It is installed on your Kubernetes cluster.
- Qovery Cluster Agent (optional): the Qovery Cluster Agent is responsible for securely forwarding logs and metrics from your Kubernetes cluster to Qovery control plane.
- Qovery Shell Agent (optional): the Qovery Shell Agent is responsible for giving you a secure remote shell access to your Kubernetes pods if you need it. E.g. when using `qovery shell` command.

Third-party components:
- NGINX Ingress Controller (optional)
- External DNS (optional)
- Loki (optional)
- Promtail (optional)
- Cert Manager (optional)
- ...

You can chose what you want to install and manage, and you will have a description of what services are usedi, and responsible for. You can disable them if you don't want to use them. And you can even install other components if you want to.

## What's the requirements?

Qovery requires a Kubernetes cluster with the following requirements:

- Kubernetes version 1.26 or higher
- Helm version 3.0 or higher
- 2 CPU
- 4 GB RAM
- 20 GB disk space
- Being able to access to the Internet

## Run local demo infrastructure (optional)

<Alert type="warning">

This local demo infrastructure is only for testing purpose, to quickly test Qovery. It is not supported by Qovery for production workloads. If you already have a managed Kubernetes cluster like EKS, you can skip this part.

</Alert>

First you will need some binaries to run the demo infrastructure locally:
* [docker](https://www.docker.com/): Docker is a set of platform as a service (PaaS) products that use OS-level virtualization to deliver software in packages called containers.
* [kubectl](https://kubernetes.io/docs/tasks/tools/#kubectl): Kubernetes command-line tool.
* [k3d](https://k3d.io/): k3d is a lightweight wrapper to run k3s (Rancher Labâ€™s minimal Kubernetes distribution) in docker.
* [Helm](https://helm.sh): Helm is a package manager for Kubernetes.

Qovery requires a container registry to store its images.

<Alert type="info">

We will use [ECR](https://aws.amazon.com/ecr/) to have a private repository for this demo, but you can chose any kind of registry (docker.io, [quay.io](https://quay.io/), GCR...).

</Alert>

We have to use a binary for ECR authentication and token rotation. So we create the prerequired folders and file for the binary:
```
mkdir -p registry/bin
touch registry/bin/ecr-credential-provider
chmod 755 registry/bin/ecr-credential-provider
```
Note: the ecr-credential-provider binary should be present for k3s to start. We will build it later.

And create an IAM user with the following policy:
```json
{
    "Statement": [
        {
            "Action": [
                "ecr:*",
            ],
            "Effect": "Allow",
            "Resource": "*"
        }
    ],
    "Version": "2012-10-17"
}
```

Then we create a `registry/config.yaml` file to configure the ECR credential provider, where you should set the AWS credentials:
```yaml
apiVersion: kubelet.config.k8s.io/v1
kind: CredentialProviderConfig
providers:
  - name: ecr-credential-provider
    matchImages:
      - "*.dkr.ecr.*.amazonaws.com"
      - "*.dkr.ecr.*.amazonaws.com.cn"
      - "*.dkr.ecr-fips.*.amazonaws.com"
      - "*.dkr.ecr.us-iso-east-1.c2s.ic.gov"
      - "*.dkr.ecr.us-isob-east-1.sc2s.sgov.gov"
    defaultCacheDuration: "12h"
    apiVersion: credentialprovider.kubelet.k8s.io/v1
    env:
      - name: AWS_ACCESS_KEY_ID
        value: xxx
      - name: AWS_DEFAULT_REGION
        value: xxx
      - name: AWS_SECRET_ACCESS_KEY
        value: xxx
```

Now we can run a local Kubernetes cluster:
```bash
k3d cluster create --k3s-arg "--disable=traefik,metrics-server@server:0" \
-v $(pwd)/registry/bin:/var/lib/rancher/credentialprovider/bin@server:0  \
-v $(pwd)/registry/config.yaml:/var/lib/rancher/credentialprovider/config.yaml@server:0
```

After a few seconds/minutes (depending on your network bandwidth), you should have a local Kubernetes cluster running. Deploy this job to build and deploy the ECR credential provider binary on k3d (`job.yaml`):
```yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: cloud-provider-repository-binary-builder
spec:
  backoffLimit: 0
  template:
    spec:
      restartPolicy: Never
      containers:
      - name: ecr-credential-builder
        image: alpine:3.18
        command:
          - /bin/sh
          - -c
          - |
            apk add -U ca-certificates tar zstd tzdata go git
            git clone https://github.com/kubernetes/cloud-provider-aws.git
            cd cloud-provider-aws/cmd/ecr-credential-provider
            CGO_ENABLED=0 go build -mod=readonly .
            chmod 755 ecr-credential-provider
            mkdir -p /mnt/host/var/lib/rancher/credentialprovider/bin/
            cp ecr-credential-provider /mnt/host/var/lib/rancher/credentialprovider/bin/
        volumeMounts:
        - mountPath: /mnt/host
          name: host
      volumes:
      - hostPath:
          path: /
          type: ""
        name: host
```

```
kubectl apply -f job.yaml
```

You should have see those pods running:
```bash
$ kubectl get po -A
NAMESPACE     NAME                                             READY   STATUS      RESTARTS   AGE
kube-system   local-path-provisioner-957fdf8bc-nwz5q           1/1     Running     0          112m
kube-system   coredns-77ccd57875-jhcnk                         1/1     Running     0          112m
default       cloud-provider-repository-binary-builder-4cvsv   0/1     Completed   0          112m
```

You're now ready to move on.

## Install Qovery

<Steps headingDepth={3}>

<ol>

<li>

Install [Helm][urls.helm] command line tool.

</li>

<li>

Add Qovery Helm repository.

```bash
helm repo add qovery https://helm.qovery.com
helm repo update
```

</li>

<li>

Login to the Qovery console, create a cluster until it's asked to save informations in the `values.yaml` file.

</li>

<li>

You will find several `values.yaml` files. Depending on you need, select the one you want and update the configuration accordingly:
* `values-demo.yaml`: this version is to locally test with k3s or minikube
* `values-<provider-name>.yaml`: find versions made for some providers

<Alert type="info">

Note: The provided values files are examples. There is no restriction where Qovery can be deployed. Feel free to copy or use an existing example and adapt it to your needs.

</Alert>

Here is an example of how the chart works:
<details><summary>values-demo.yaml</summary>

```yaml
## Services you can enable or disable
services:
  qovery:
    qovery-cluster-agent:
      enabled: true
    qovery-shell-agent:
      enabled: true
    qovery-engine:
      enabled: true
  ingress:
    ingress-nginx:
      enabled: true
  dns:
    external-dns:
      enabled: true
  logging:
    loki:
      enabled: true
    promtail:
      enabled: true
  certificates:
    cert-manager:
      enabled: true
    qovery-cert-manager-webhook:
      enabled: true
    cert-manager-configs:
      enabled: true
  observability:
    metrics-server:
      enabled: true

## Qovery Common config
# Past information from Qovery cluster console creation

qovery:
  clusterId: &clusterId "set-by-customer"
  clusterShortId: &shortClusterId "set-by-customer"
  organizationId: &organizationId "set-by-customer"
  jwtToken: &jwtToken "set-by-customer"
  domain: &domain "set-by-customer"
  grpcServer: &grpcServer "set-by-customer"
  engineGrpcServer: &engineGrpcServer "set-by-customer"
  qoveryDnsUrl: &qoveryDnsUrl "set-by-customer"
  lokiUrl: &lokiUrl "set-by-customer"
  promtailLokiUrl: &promtailLokiUrl "set-by-customer"
  acmeEmailAddr: &acmeEmailAddr "set-by-customer"
  externalDnsPrefix: &externalDnsPrefix "set-by-customer"
  architectures: &architectures "set-by-customer"

## Chart overrides
...
```

</details>

</li>

<li>

Install Qovery on your Kubernetes cluster.

```bash
helm upgrade --install -n qovery -f values-demo.yaml qovery
```
* `-n qovery`: the namespace where Qovery and its dependencies will be installed
* `-f values-demo.yaml`: specify the values overrides file you want to use
* `qovery`: name of the chart to deploy

</li>

</ol>

</Steps>

## Configuration

### Qovery

This is the configuration of Qovery itself. It is used by all Qovery components.

| Key                        | Required | Description                                                    | Default                   |
|----------------------------|----------|----------------------------------------------------------------|---------------------------|
| `qovery.clusterId`         | Yes      | The cluster ID. It is used to identify your cluster.           | `set-by-customer`         |
| `qovery.shortClusterId`    | Yes      | The short cluster ID. It is used to identify your cluster.     | `set-by-customer`         |
| `qovery.organizationId`    | Yes      | The organization ID. It is used to identify your organization. | `set-by-customer`         |
| `qovery.jwtToken`          | Yes      | The JWT token. It is used to authenticate your cluster.        | `set-by-customer`         |
| `qovery.domain`            | Yes      | The domain name used by Qovery.                                | `set-by-customer`         |
| `qovery.qoveryDnsUrl`      | Yes      | Qovery DNS url in case you want to use Qovery provided DNS     | `set-by-customer`         |
| `qovery.lokiUrl`           | No       | Local Loki URL (required if Loki is set)                       | `set-by-customer`         |
| `qovery.promtailLokiUrl`   | No       | Promtail Loki URL (required if Promtail and Loki are set)      | `set-by-customer`         |
| `qovery.acmeEmailAddr`     | No       | Email address used for `Let's Encrypt` TLS requests            | `set-by-customer`         |
| `qovery.externalDnsPrefix` | No       | ExernalDNS TXT record prefix (required if ExternalDNS is set)  | `set-by-customer`         |
| `qovery.architectures`     | No       | Set cluster architectures (comma separated)                    | `AMD64`                   |

<Alert type="danger">

**Do not share the jwtToken! Keep it in a safe place.** It is used to authenticate the cluster.

</Alert>

#### Qovery Cluster Agent

<Alert type="info">

Optional. If you don't want to use the cluster agent, you can disable it. You will not be able to see your logs and metrics in the Qovery dashboard.

</Alert>

The cluster agent is responsible for securely forwarding logs and metrics from your Kubernetes cluster to Qovery control plane.

| Key                                                                    | Required | Description                          | Default           |
|------------------------------------------------------------------------|----------|--------------------------------------|-------------------|
| `services.qovery-cluster-agent.environmentVariables.GRPC_SERVER`       | Yes      | The gRPC server URL.                 | `set-by-customer` |
| `services.qovery-cluster-agent.environmentVariables.CLUSTER_JWT_TOKEN` | Yes      | The JWT token.                       | `set-by-customer` |
| `services.qovery-cluster-agent.environmentVariables.CLUSTER_ID`        | Yes      | The cluster ID.                      | `set-by-customer` |
| `services.qovery-cluster-agent.environmentVariables.ORGANIZATION_ID`   | Yes      | The organization ID.                 | `set-by-customer` |

#### Qovery Shell Agent

<Alert type="info">

Optional. If you don't want to use the shell agent, you can disable it. You will not be able to open a secure remote shell to your application.

</Alert>

The shell agent is responsible for giving you a secure remote shell access to your Kubernetes pods if you need it. E.g. when using `qovery shell` command.

| Key                                                                   | Required | Description                         | Default           |
|-----------------------------------------------------------------------|----------|-------------------------------------|-------------------|
| `services.qovery-shell-agent.environmentVariables.GRPC_SERVER`        | Yes      | The gRPC server URL.                | `set-by-customer` |
| `services.qovery-shell-agent.environmentVariables.CLUSTER_JWT_TOKEN`  | Yes      | The JWT token.                      | `set-by-customer` |
| `services.qovery-shell-agent.environmentVariables.CLUSTER_ID`         | Yes      | The cluster ID.                     | `set-by-customer` |
| `services.qovery-shell-agent.environmentVariables.ORGANIZATION_ID`    | Yes      | The organization ID.                | `set-by-customer` |

### Ingress

<Alert type="info">

Optional. To be able to expose web services privately or publicly, an Ingress is required. If you don't need it, you can disable the service.

</Alert>

Qovery uses [NGINX Ingress Controller](https://docs.nginx.com/nginx-ingress-controller/) by default to route traffic to your applications.

#### Nginx Ingress Controller

Here is the minimum override configuration to be used:

```yaml
ingress-nginx:
  fullnameOverride: ingress-nginx
  controller:
    useComponentLabel: true
    admissionWebhooks:
      enabled: false
    # Ingress class used when an application/container with public access is set
    ingressClass: nginx-qovery
    extraArgs:
      # Default TLS certificate name and path
      default-ssl-certificate: "qovery/letsencrypt-acme-qovery-cert"
    # Allows customization of the source of the IP address or FQDN to report in the ingress status field
    publishService:
      enabled: true
```


#### Other Ingress Controllers

Qovery supports other Ingress Controllers. Please contact us if you want to use another one. We will be happy to help you.

### DNS

<Alert type="info">

Optional but strongly recommended. Used to easily reach your applications with DNS records, even on private network.

</Alert>

Qovery uses [External DNS](https://github.com/kubernetes-sigs/external-dns) to automatically configure DNS records for your applications.

If you don't want or can't add your own DNS provider, you can use the Qovery DNS provider. It is a managed DNS provider by Qovery with a sub-domain given by Qovery for free.
You'll then be able to later add your custom DNS record (no matter the provider) to point to your Qovery DNS sub-domain.

#### External DNS

Here is one example with Qoery DNS provider:
```yaml
external-dns:
  fullnameOverride: external-dns
  # set pdns for Qovery DNS managed (or you can use any supported provider by external-dns)
  provider: pdns
  # will use the domain name given by Qovery during the cluster setup phease
  domainFilters: [*domain]
  # an owner ID is set to avoid conflicts in case of multiple Qovery clusters
  txtOwnerId: *shortClusterId
  # a prefix to help Qovery to debug in case of issues
  txtPrefix: *externalDnsPrefix
  # set the Qovery DNS provider configuration
  pdns:
    apiUrl: *qoveryDnsUrl
    apiKey: *jwtToken
    apiPort: 443
```

### Logging

<Alert type="info">

Optional but strongly recommended. Promtail and Loki are not mandatory to use Qovery. However, it's required if you want to have log history and reduce Kubernetes API load.

</Alert>

Qovery uses [Loki](https://grafana.com/oss/loki/) to store your logs and [Promtail](https://grafana.com/docs/loki/latest/clients/promtail/) to collect your logs.

#### Loki

```yaml
loki:
  fullnameOverride: loki
  loki:
    # no auth is set for internal cluster usage
    auth_enabled: false
    ingester:
      lifecycler:
        ring:
          kvstore:
            # we store it in memory for the demo, you'll lose history once Loki restarts
            store: inmemory
          replication_factor: 1
    schema_config:
      configs:
        - from: 2020-05-15
          store: boltdb-shipper
          object_store: filesystem
          schema: v11
          index:
            prefix: index_
            period: 24h
  monitoring:
    # all the monitoring part is disabled to reduce resource footprint for the demo usage
    dashboards:
      enabled: false
    rules:
      enabled: false
    serviceMonitor:
      enabled: false
      metricsInstance:
        enabled: false
    selfMonitoring:
      enabled: false
      grafanaAgent:
        installOperator: false
    grafanaAgent:
      enabled: false
    lokiCanary:
      enabled: false
  test:
    enabled: false
  gateway:
    enabled: false
  # we use a single binary to reduce resource footprint for the demo usage
  singleBinary:
    replicas: 1
    persistence:
      enabled: false
    extraVolumes:
      - name: data
        emptyDir: {}
      - name: storage
        emptyDir: {}
    extraVolumeMounts:
      - name: data
        mountPath: /data
      - name: storage
        mountPath: /var/loki
```

#### Promtail

```yaml
promtail:
  fullnameOverride: promtail
  # promtail requires to be spawned in kube-system namespace
  namespace: kube-system
  priorityClassName: system-node-critical
  config:
    clients:
      # forward logs to Loki
      - url: *promtailLokiUrl
    snippets:
      extraRelabelConfigs:
        - action: labelmap
          # required to be able to watch logs from Qovery console interface
          regex: __meta_kubernetes_pod_label_(qovery_com_service_id|qovery_com_service_type|qovery_com_environment_id)
```

### Certificates

<Alert type="info">

Optional but strongly recommended. Cert-manager helps you to get TLS certificates through Let's Encrypt. Without it, you will not be able to automatically get TLS certificates.

</Alert>

Qovery uses [Cert Manager](https://cert-manager.io/) to automatically get TLS certificates for your applications.

#### Cert Manager

```yaml
cert-manager:
  fullnameOverride: cert-manager
  # CRD are required
  installCRDs: true
  replicaCount: 1
  startupapicheck:
    jobAnnotations:
      helm.sh/hook: post-install,post-upgrade
    rbac:
      annotations:
        helm.sh/hook: post-install,post-upgrade
    serviceAccount:
      annotations:
        helm.sh/hook: post-install,post-upgrade
```

#### Qovery Cert Manager Webhook

<Alert type="info">

Optional and only required if you're using Qovery DNS provider. Set this to get automatic TLS certificates by Qovery.

</Alert>

```yaml
qovery-cert-manager-webhook:
  fullnameOverride: qovery-cert-manager-webhook
  certManager:
    namespace: qovery
    serviceAccountName: cert-manager
  secret:
    apiUrl: *qoveryDnsUrl
    apiKey: *jwtToken
```

#### Cert Manager Configs

This is the configuration of Cert Manager itself. It is used by all Cert Manager components.

```yaml
cert-manager-configs:
  fullnameOverride: cert-manager-configs
  # set pdns to use Qovery DNS provider
  externalDnsProvider: pdns
  managedDns: [*domain]
  acme:
    letsEncrypt:
      emailReport: *acmeEmailAddr
      # As it's a demo cluster, we use the staging environment to avoid rate limit issues
      acmeUrl: https://acme-staging-v02.api.letsencrypt.org/directory
  provider:
    # set the provider of your choice or use the Qovery DNS provider
    pdns:
      apiPort: 443
      apiUrl: *qoveryDnsUrl
      apiKey: *jwtToken
```

Qovery uses [Metrics Server](https://github.com/kubernetes-sigs/metrics-server) to collect metrics from your Kubernetes cluster and scale your applications automatically based on custom metrics.

## Observability

### Metrics Server

<Alert type="info">

Optional but strongly recommended. Without metrics server, you will not be able to scale your applications automatically and will not have metrics information in the Qovery dashboard.

</Alert>

```yaml
metrics-server:
  fullnameOverride: metrics-server
  defaultArgs:
    - --cert-dir=/tmp
    - --kubelet-preferred-address-types=InternalIP,ExternalIP,Hostname
    - --kubelet-use-node-status-port
    - --metric-resolution=15s
    - --kubelet-insecure-tls
  apiService:
    create: false
```

## FAQ

### I have a non-covered use case. What should I do?

Please [contact us][urls.qovery_contact_us]. We will be happy to help you.

### Can I host the Qovery control plane on my own?

At the momement, you can't. But please [contact us][urls.qovery_contact_us] to discuss about it. We will be happy to help you.

---
last_modified_on: "2024-02-28"
$schema: "/.meta/.schemas/guides.json"
title: URL Shortener API with Kotlin (Part 1/2)
description: Create a URL shortener API with Kotlin, the micro-framework Ktor and PostgreSQL
author_github: https://github.com/evoxmusic
tags: ["type: tutorial", "language: kotlin", "database: postgresql"]
hide_pagination: true
---

import Alert from '@site/src/components/Alert';
import Jump from '@site/src/components/Jump';
import Steps from '@site/src/components/Steps';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

import Assumptions from '@site/src/components/Assumptions';

The source code for this post can be found on this [github repo](https://github.com/evoxmusic/ktor-url-shortener)

<!--
     THIS FILE IS AUTOGENERATED!

     To make changes please edit the template located at:

     website/guides/tutorial/url-shortener-api-with-kotlin.md.erb
-->

## Introduction

[Ktor](https://ktor.io/) is a brand new micro-framework created by the Jetbrains team, and running over the JVM. Jetbrains are the authors of [Kotlin](https://kotlinlang.org/) - which is now the official programming language for Android, and one of the most popular programming language on the JVM. Kotlin is gaining popularity on server-side and multi-platform application development.

> Ktor is a framework for building asynchronous servers and clients in connected systems using the powerful Kotlin programming language.

In this article, you will learn:

* How to design a simple URL shortener.
* How to use the Ktor micro-framework with Kotlin
* How to deploy a Ktor application

I have +4 years of experience using Spring, and I wanted to give a try to Ktor, which seems promising. Creating a URL shortener is an excellent way to start.

## What is a URL shortener?
A URL shortener is a simple tool that takes a long URL and turns it into a very short one

![Flow of URL shortening - from original URL to short URL](https://uploads-ssl.webflow.com/5de176c0d41c9b4a1dbbb0aa/5e655859bc2ae5c7371efa36_urlshortener%20image.png)

It is commonly used for 3 reasons:

* Tracking clicks
* Make URL much more concise.
* Hide original URL

One famous freemium provider is bit.ly (see [here](https://uploads-ssl.webflow.com/5de176c0d41c9b4a1dbbb0aa/5e655a34bc2ae5452b1f124b_bitly.gif))

In this article we will make a basic bit.ly like URL shortener. Let’s go

## Ktor principles

Before starting I want to introduce the 3 main principles of Ktor.

### Kotlin

Kotlin is the language used to develop on Ktor. It is an object-oriented and functional language. It is very stable and runs on the JVM. Kotlin is 100% interoperable with Java and allows you to benefit from its ecosystem (libraries, build system, etc.).

### Functional programming

Ktor leverages the power of Kotlin and has a very functional approach. When writing code, everything seems obvious. It's very similar to what you can see on NodeJS. For me, coming from the Spring world, I find it very efficient to read and use.

### Asynchronous

Kotlin provides asynchronous code execution, thanks to [coroutines](https://kotlinlang.org/docs/reference/coroutines-overview.html). Ktor exploits this feature to its full potential, and even if you have the impression that you are writing code in a blocking manner, this is not the case. Ktor makes your life easier.

## HTTP Server

Here is a complete and simple example of how to expose an HTTP server (http://localhost:8080) with Ktor.
```kotlin
fun main(args: Array<String>): Unit = io.ktor.server.netty.EngineMain.main(args)

@kotlin.jvm.JvmOverloads
fun Application.module(testing: Boolean = false) {
    routing {
        get("/") {
            call.respondText("Hello World", contentType = ContentType.Text.Plain)
        }
    }
}
```

## URL Encoder

The URL encoder will translate an incoming address into a smaller URL. The idea is to provide an ID that will identify the final URL. Using a hash function is perfect for this operation. However, the operation is non-reversible, meaning you can’t retrieve the final URL by the generated identifier.

Function to transform a long URL into a shorter URL
```kotlin
// String extension
fun String.encodeToID(): String {
    // hash String with MD5
    val hashBytes = MessageDigest.getInstance("MD5").digest(this.toByteArray(Charsets.UTF_8))
    // transform to human readable MD5 String
    val hashString = String.format("%032x", BigInteger(1, hashBytes))
    // truncate MD5 String
    val truncatedHashString = hashString.take(6)
    // return id
    return truncatedHashString
}
```

We expose the function through the REST API
```kotlin
// Request object
data class Request(val url: String) {
    fun toResponse(): Response = Response(url, url.encodeToID())
}

// Response object
data class Response(val originalURL: String, private val id: String) {
    val shortURL: String = "http://localhost:8080/$id"
}

@kotlin.jvm.JvmOverloads
fun Application.module(testing: Boolean = false) {
    install(ContentNegotiation) {
        jackson {
            enable(SerializationFeature.INDENT_OUTPUT)
            propertyNamingStrategy = PropertyNamingStrategy.SNAKE_CASE
        }
    }

    // Hash Table Response object by ID
    val responseByID = mutableMapOf<String, Response>()

    routing {
        post("/api/v1/encode") {
            // Deserialize JSON body to Request object
            val request = call.receive<Request>()

            // find the Response object if it already exists
            val retrievedResponse = responseByID[request.url.encodeToID()]
            if (retrievedResponse != null) {
                // cache hit
                log.debug("cache hit $retrievedResponse")
                return@post call.respond(retrievedResponse)
            }

            // cache miss
            val response = request.toResponse()
            responseByID[request.url.encodeToID()] = response
            log.debug("cache miss $response")

            // Serialize Response object to JSON body
            call.respond(response)
        }
    }
}
```

### Handle identifier collision

Using a hash function makes no guarantee that it is not already being used. If it is in use, then you need to change it to another one. Note: even if the probability to have a collision is very low, you should handle this case.

```kotlin
// String extension (function signature has changed)
fun String.encodeToID(truncateLength: Int = 6): String {
    // hash String with MD5
    val hashBytes = MessageDigest.getInstance("MD5").digest(this.toByteArray(Charsets.UTF_8))
    // transform to human readable MD5 String
    val hashString = String.format("%032x", BigInteger(1, hashBytes))
    // truncate MD5 String
    val truncatedHashString = hashString.take(truncateLength)
    // return id
    return truncatedHashString
}

//...

@kotlin.jvm.JvmOverloads
fun Application.module(testing: Boolean = false) {
		// ...
    // Hash Table Response object by id
    val responseByID = mutableMapOf<String, Response>()

    fun getIdentifier(url: String, truncateLength: Int = 6): String {
        val id = url.encodeToID()

        val retrievedResponse = responseByID[id]
        if (retrievedResponse?.originalURL != url) {
            // collision spotted !
            return getIdentifier(url, truncateLength + 1)
        }

        return id
    }

    routing {
        post("/api/v1/encode") {
            // Deserialize JSON body to Request object
            val request = call.receive<Request>()

            // find the Response object if it already exists
            val id = getID(request.url)
            val retrievedResponse = responseByID[id]
            if (retrievedResponse != null) {
                // cache hit
                log.debug("cache hit $retrievedResponse")
                return@post call.respond(retrievedResponse)
            }

            // cache miss
            val response = request.toResponse()
            responseByID[id] = response
            log.debug("cache miss $response")

            // Serialize Response object to JSON body
            call.respond(response)
        }
    }
}
```

## URL Decoder

Decoding the URL is the process of returning the original URL from the short URL. This is the reverse operation made by the URL Encoder

```kotlin
val shortURL = getShortURL(request.url)
val retrievedResponse = responseByID[shortURL]
retrievedResponse?.originalURL // return original URL or null
```

## Redirect

When a user clicks on a short URL, the user is redirected to the final URL. HTTP protocol allows to do this naturally by returning a 302 status code and a redirection URL.

With Ktor the redirection is as simple as calling a method with the final URL as a parameter.

```kotlin
call.respondRedirect("https://www.qovery.com")
```

What we expect is that when the user visits http://localhost:8080/fbc951 he is redirected to https://www.qovery.com. If the URL is incorrect then redirect to https://www.google.com

```kotlin
@kotlin.jvm.JvmOverloads
fun Application.module(testing: Boolean = false) {
		// ...
    routing {
        get("/{id}") {
            val id = call.parameters["id"]
            val retrievedResponse = id?.let { responseByID[it] }

            if (id.isNullOrBlank() || retrievedResponse == null) {
                return@get call.respondRedirect("https://www.google.com")
            }

            log.debug("redirect to: $retrievedResponse")
            call.respondRedirect(retrievedResponse.originalURL)
        }
        // ...
    }
}
```

## Stats: clicks over time

Something that is really useful on products like bit.ly is the stats provided (click over time, referrers, country of visitors). Here is how to store click over time and make them available through the API

```kotlin
// added
data class Stat(val clicksOverTime: MutableList<Date> = mutableListOf())

// Response object (modified with Stat)
data class Response(val originalURL: String, private val id: String, val stat: Stat = Stat()) {
    val shortURL: String = "http://localhost:8080/$id"
}

@kotlin.jvm.JvmOverloads
fun Application.module(testing: Boolean = false) {
		install(ContentNegotiation) {
        jackson {
            // ...
            // add this line to return Date object as ISO8601 format
            disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)
        }
    }
		// ...
    routing {
    		// ...
        get("/api/v1/url/{id}/stat") {
            val id = call.parameters["id"]
            val retrievedResponse = id?.let { responseByID[it] }

            if (id.isNullOrBlank() || retrievedResponse == null) {
                return@get call.respond(HttpStatusCode.NoContent)
            }

            call.respond(retrievedResponse.stat)
        }
        // ...
    }
}
```

## Try the API

Run the application
```bash
$ ./gradlew run
//...
2020-03-12 09:28:08.150 [main] INFO  Application - No ktor.deployment.watch patterns specified, automatic reload is not active
2020-03-12 09:28:08.606 [main] INFO  Application - Responding at http://0.0.0.0:8080
```

Then execute the commands
```bash
# generate a short URL
$ curl -X POST -d '{"url": "https://www.qovery.com"}' -H "Content-type: application/json" "http://localhost:8080/api/v1/encode"
{
  "original_url": "https://www.qovery.com",
  "stat": {
    "clicks_over_time": []
  },
  "short_url": "http://localhost:8080/fbc951"
}

# generate 4 fake clicks
$ curl -X GET 'http://localhost:8080/fbc951'
$ curl -X GET 'http://localhost:8080/fbc951'
$ curl -X GET 'http://localhost:8080/fbc951'
$ curl -X GET 'http://localhost:8080/fbc951'

# show stat
$ curl -X GET 'http://localhost:8080/api/v1/url/fbc951/stat'
{
  "clicks_over_time": [
    "2020-03-11T21:10:52.354+0000",
    "2020-03-11T21:10:54.093+0000",
    "2020-03-11T21:12:34.987+0000",
    "2020-03-11T21:12:37.223+0000"
  ]
}
```

## Connect to a PostgreSQL database with Exposed

By storing the data in memory, we lose all the data every time the application restart. Which is problematic for running in production. To make the data persistent we will store it in a PostgreSQL database. We will have to add 1 new dependency - [Exposed](https://github.com/JetBrains/Exposed). Exposed (with [Hikari Connection Pool](https://github.com/brettwooldridge/HikariCP)) is a lightweight SQL library on top of JDBC driver for Kotlin. With exposed it is possible to access databases in two flavours: typesafe SQL wrapping DSL and lightweight Data Access Objects (DAO).

Add the dependencies to your build.gradle (or POM.xml)

```kotlin
repositories {
  jcenter()
}

dependencies {
  // Connection Pool and PostgreSQL driver
  implementation("com.zaxxer:HikariCP:3.4.2")
  implementation("org.postgresql:postgresql:42.2.11")

  // Exposed
  implementation("org.jetbrains.exposed:exposed-core:0.22.1")
  implementation("org.jetbrains.exposed:exposed-dao:0.22.1")
  implementation("org.jetbrains.exposed:exposed-jdbc:0.22.1")
  implementation("org.jetbrains.exposed:exposed-java-time:0.22.1")
}
```

We need to have 2 distincts tables, one containing all the final URLs with their correspond identifier

```kotlin
object ResponseTable : Table("response") {
    val id = varchar("id", 32)
    val originalURL = varchar("original_url", 2048)
    override val primaryKey: PrimaryKey = PrimaryKey(id)
}
```

And a second one with all the clicking points

```kotlin
object ClickOverTimeTable : Table("click_over_time") {
    val id = integer("id").autoIncrement()
    val clickDate = datetime("click_date")
    val response = reference("response_id", onDelete = ReferenceOption.CASCADE, refColumn = ResponseTable.id)
    override val primaryKey: PrimaryKey = PrimaryKey(id)
}
```

We need to create the tables as defined above programmatically

```kotlin
fun initDatabase() {
    val config = HikariConfig().apply {
        jdbcUrl = "jdbc:postgresql://127.0.0.1:5432/exposed"
        username = "exposed"
        password = "exposed"
        driverClassName = "org.postgresql.Driver"
    }

    Database.connect(HikariDataSource(config))

    transaction {
        // create tables if they do not exist
        SchemaUtils.createMissingTablesAndColumns(RequestTable, ClickOverTimeTable)
    }
}

@kotlin.jvm.JvmOverloads
fun Application.module(testing: Boolean = false) {
    initDatabase()
    // ...
}
```

We have to replace the Hash Table used to store the data by the PostgreSQL database (see the final code [here](https://github.com/evoxmusic/ktor-url-shortener/blob/with_postgresql/src/Application.kt))

## Deploy in the Cloud with Qovery

[Qovery](https://www.qovery.com) is going to help us to deploy the final application in the Cloud without the need to configure the CI/CD, network, security, load balancing, database and all the DevOps tasks

> Qovery is a deployment platform that helps all developers to deploy their applications in the Cloud in just a few seconds

<Assumptions name="tutorial">

* Your code need to be hosted on Github/Gitlab/Bitbucket
* [Package your Ktor application to build and run it on Docker](https://ktor.io/quickstart/quickstart/docker.html)

</Assumptions>

<Tabs
  centered={true}
  className={"rounded"}
  defaultValue={"web"}
  placeholder="Select your interface"
  select={false}
  size={null}
  values={[{"group":"Interfaces","label":"Web","value":"web"},{"group":"Interfaces","label":"CLI","value":"cli"}]}>

<TabItem value="web">

<li>

Sign in to the [Qovery web interface][urls.start_qovery].

<p align="center">
  <a href="https://onboarding.qovery.com/"><img src="/img/Qovery_Sign_Up_Page.png" alt="Qovery Sign-up page" /></a>
</p>

</li>

</TabItem>

<TabItem value="cli">

<li>

### Install Qovery CLI

<Tabs
  centered={true}
  className={"rounded"}
  defaultValue={"linux"}
  placeholder="Select your OS"
  select={false}
  size={null}
  values={[{"group":"Platforms","label":"Linux","value":"linux"},{"group":"Platforms","label":"MacOS","value":"macos"},{"group":"Platforms","label":"Windows","value":"windows"},{"group": "Platforms","label":"Docker","value":"docker"}]}>

<TabItem value="linux">

<Tabs
  centered={true}
  className="rounded"
  defaultValue="universal"
  values={[{"label":"*nix","value":"universal"},{"label":"Arch Linux","value":"arch"},{"label":"Manual","value":"manual"}]}>

<TabItem value="universal">

To download and install Qovery CLI on any Linux distribution:
```bash
$ curl -s https://get.qovery.com | bash
```

</TabItem>
<TabItem value="arch">

Qovery is part of [AUR](https://aur.archlinux.org/packages) packages, so you can install it with [yay](https://github.com/Jguer/yay):

```bash
$ yay qovery-cli
```

</TabItem>
<TabItem value="manual">

Install the Qovery CLI on Linux manually by downloading the [latest release][urls.qovery_cli_releases], and uncompress its content to a folder into your shell `PATH`.

</TabItem>
</Tabs>
</TabItem>

<TabItem value="macos">

<Tabs
  centered={true}
  className="rounded"
  defaultValue="homebrew"
  values={[{"label":"Homebrew","value":"homebrew"},{"label":"Script","value":"script"},{"label":"Manual","value":"manual"}]}>

<TabItem value="homebrew">

The common solution to install a command line binary on the MacOS is to use [Homebrew][urls.brew].

```bash
# Add Qovery brew repository
$ brew tap Qovery/qovery-cli

# Install the CLI
$ brew install qovery-cli
```

</TabItem>

<TabItem value="script">

To download and install Qovery CLI from the command line:
```bash
$ curl -s https://get.qovery.com | bash
```

</TabItem>

<TabItem value="manual">

Install the Qovery CLI on Mac OS manually by downloading the [latest release][urls.qovery_cli_releases], and uncompress its content to a folder into your shell `PATH`.

</TabItem>

</Tabs>

</TabItem>

<TabItem value="windows">

<Tabs
  centered={true}
  className="rounded"
  defaultValue="scoop"
  values={[{"label":"Scoop","value":"scoop"},{"label":"Manual","value":"manual"}]}>

<TabItem value="scoop">

The classic way to install binaries on Windows is to use [Scoop][urls.scoop].

```bash
# Add Qovery bucket
$ scoop bucket add qovery https://github.com/Qovery/scoop-qovery-cli

# Install the CLI
$ scoop install qovery-cli
```

</TabItem>

<TabItem value="manual">

Install the Qovery CLI on Windows manually by downloading the [latest release][urls.qovery_cli_releases], and uncompress its content to
`C:\Windows`.

</TabItem>

</Tabs>

</TabItem>


<TabItem value="docker">

Install Docker on your local machine and run the following command:

```bash
# Pull and Run the latest Qovery CLI
$ docker run ghcr.io/qovery/qovery-cli:latest help
```

Change `latest` by the version you want to use. For example, to use the version 0.58.4, run:

```bash
$ docker run ghcr.io/qovery/qovery-cli:0.58.4 help
```

Note: `ghcr.io` is the [GitHub Container Registry](https://github.com/Qovery/qovery-cli/pkgs/container/qovery-cli).

</TabItem>

</Tabs>

</li>

<li>

### Sign up

```bash
# Sign up and sign in command
$ qovery auth
```

<Alert type="info">

If you are using an environment without access to GUI or a browser, you can use headless authentication instead:

```bash
# Sign up and sign in command
$ qovery auth --headless
```

</Alert>

Your browser window with sign-in options will open.

<p align="center">
  <img src="/img/qovery_signup.svg" alt="Qovery Sign-up page" />
</p>

[Click here][urls.authorize_qovery] to authorize Qovery to clone and build your applications.

<p align="center">
  <img src="/img/github_signup.svg" alt="Connect Github" />
</p>

Congratulations, you are logged-in.

</li>

</TabItem>

</Tabs>

### Create an application

<Steps headingDepth={3}>
<ol>

<li>

### Create a new project

<p align="center">
  <img src="/img/heroku/heroku-2.png" alt="Migrate from Heroku" />
</p>

</li>

<li>

### Create a new environment

<p align="center">
  <img src="/img/heroku/heroku-3.png" alt="Migrate from Heroku" />
</p>

</li>

<li>

### Create a new application

To follow the guide, <a href="https://github.com/evoxmusic/ktor-url-shortener.git">you can fork and use our repository</a>

Use the forked repository (and branch **master**) while creating the application in the repository field:

<p align="center">
  <img src="/img/rust/rust.png" alt="Migrate from Heroku" />
</p>

</li>

<li>

After the application is created: 

- Navigate application settings
- Select **Port**
- Add port 8080

<p align="left">
    <img src="/img/micro/micros-1.png" alt="Microservices" />
</p>

This will expose your application and make accessible in the public internet.

</li>
</ol>
</Steps>

### Deploy a database

Create and deploy a new database.

<Alert type="warning">
Name the new database **my-pql-db** to follow the guide flawlessly
</Alert>

To learn how to do it, you can [follow this guide][guides.getting-started.create-a-database].

### Connect to PostgreSQL

Qovery add dynamically all required environment variables to connect to the database at the runtime of the container.

You can list them all in **Environment Variables** **Secrets** section in your application overview, as described in [envs guide][guides.getting-started.managing-environment-variables].

<p align="center">
  <img src="/img/db-envs.png" alt="DB Secrets" />
</p>

To use them:

```kotlin
fun initDatabase() {
    val config = HikariConfig().apply {
        jdbcUrl = "jdbc:${System.getenv("QOVERY_DATABASE_MY_PQL_DB_CONNECTION_URI_WITHOUT_CREDENTIALS")}"
        username = System.getenv("QOVERY_DATABASE_MY_PQL_DB_USERNAME")
        password = System.getenv("QOVERY_DATABASE_MY_PQL_DB_PASSWORD")
        driverClassName = "org.postgresql.Driver"
    }

    Database.connect(HikariDataSource(config))

    transaction {
        // create tables if they do not exist
        SchemaUtils.createMissingTablesAndColumns(RequestTable, ClickOverTimeTable)
    }
}
```

### Deploy

To deploy your application and database, click **Action** and **Deploy** button in your environments list view:

<p align="center">
  <img src="/img/deploy-env.png" alt="Kotlin URL Shortener" />
</p>

To get public URL to the application, open application details and click on **Action** **Open**.

<p align="center">
  <img src="/img/deploy-env-1.png" alt="Kotlin URL Shortener" />
</p>

<p align="center">
  <img src="/img/open-app.png" alt="Kotlin URL Shortener" />
</p>

## Conclusion

We have seen that creating an URL shortener API with Ktor and Kotlin is extremely simple. Connecting the application to PostgreSQL is very easy with the Exposed library. In just a few lines of code, the service is fully functional and can be deployed in production very quickly with the help of Qovery. In the next part, we will see how to create a web interface connecting to this API to convert our URLs without using the curl command.

**Part 2**: bind a web interface to the API - [link coming soon]

<Jump to="/guides/tutorial/">Tutorial</Jump>


[guides.getting-started.create-a-database]: /guides/getting-started/create-a-database/
[guides.getting-started.managing-environment-variables]: /guides/getting-started/managing-environment-variables/
[urls.authorize_qovery]: https://github.com/apps/qovery/installations/new
[urls.brew]: https://brew.sh/
[urls.qovery_cli_releases]: https://github.com/Qovery/qovery-cli/releases
[urls.scoop]: https://scoop.sh/
[urls.start_qovery]: https://start.qovery.com

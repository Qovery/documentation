---
last_modified_on: "2025-07-07"
title: How Qovery Works
description: "An in-depth explanation of Qovery's architecture and core components"
---

Qovery is a deployment platform that makes it easy to run applications on Kubernetes, without requiring deep infrastructure expertise. It acts as a **deployment engine** that abstracts the complexity of Kubernetes and cloud-native tooling, allowing developers to focus on building while DevOps retain control.

<!--
     THIS FILE IS AUTOGENERATED!

     To make changes please edit the template located at:

     website/docs/getting-started/how-qovery-works.md.erb
-->

## üß† Key Components

Qovery is composed of two main components:

### 1. Control Plane

The Control Plane is the central orchestration system, hosted and managed by Qovery.

**Its main responsibilities include:**

- Receiving deployment instructions via API, CLI, UI, or Git
- Managing project configurations and environments
- Scheduling actions to be executed on Remote Agents
- Monitoring application health and synchronizing state
- Handling secrets, access control, and audit logs

It operates independently from your infrastructure, communicating securely with Remote Agents.

### 2. Remote Agent

The Remote Agent is a lightweight and stateless component deployed into your cloud account. It performs operations on behalf of the Control Plane.

**Responsibilities of the Remote Agent:**

- Provisioning infrastructure (VPC, clusters, databases) using Terraform
- Deploying and updating applications via Helm and Kubernetes
- Streaming logs and metrics back to the Control Plane
- Executing lifecycle actions (start, stop, restart, delete)

Agents are isolated per environment, giving you full control over infrastructure ownership and cost management.

## üîÅ High-Level Workflow

Here‚Äôs how Qovery operates from Git push to deployment:

1. **Push to Git**: A developer pushes code to a connected repository.
2. **Change Detected**: Qovery‚Äôs Control Plane detects the change via Git hooks.
3. **Plan & Orchestrate**: It computes what needs to happen (build, deploy, provision).
4. **Remote Execution**: Tasks are delegated to the appropriate Remote Agent.
5. **Deployment**: The Agent interacts with cloud and Kubernetes to apply changes.
6. **Monitoring**: Logs and metrics are sent back and displayed in the dashboard.

This process is fully automated and usually completes in less than a few minutes.

## üß± Designed for Scale

Qovery was built to support thousands of projects across hundreds of Kubernetes clusters. Its architecture is:

- **Multi-tenant by design**: Each cluster is fully isolated at the infrastructure level.
- **Cloud-agnostic**: Works on AWS, Scaleway, Azure, GCP, and others.
- **Stateless and asynchronous**: Remote Agents can recover from failure and resume tasks automatically.
- **API-first**: Every action is backed by a public API for full automation.

## üîí Secure by Default

Qovery prioritizes security in every layer:

- **No persistent credentials**: Secrets are injected securely at runtime.
- **Read-only access**: Qovery only sees metadata; code and data **stay in your infrastructure**.
- **Encrypted communications**: All traffic between components is encrypted via TLS.
- **IAM-scoped execution**: Agents operate with minimal cloud permissions.

You retain ownership of your infrastructure. Qovery only orchestrates within boundaries you define.

## üìö Further Reading

- [How We Built Qovery ‚Äì Part 1](https://www.qovery.com/blog/how-we-built-qovery---part-1)
- [Architecture Behind Qovery](https://www.qovery.com/blog/how-we-designed-qovery-to-manage-thousands-of-kubernetes-clusters)
- [Qovery CLI](https://hub.qovery.com/docs/using-qovery/interface/cli/)
- [Qovery API](https://api-doc.qovery.com/)



